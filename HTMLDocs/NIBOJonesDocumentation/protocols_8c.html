<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>NIBOJones: protocols.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>protocols.c File Reference</h1>
<p>Holds different protocols and util-methods for controlling nibo.  
<a href="#_details">More...</a></p>
<code>#include &lt;nibo/niboconfig.h&gt;</code><br/>
<code>#include &lt;nibo/iodefs.h&gt;</code><br/>
<code>#include &lt;nibo/bot.h&gt;</code><br/>
<code>#include &lt;nibo/copro.h&gt;</code><br/>
<code>#include &lt;nibo/leds.h&gt;</code><br/>
<code>#include &lt;nibo/spi.h&gt;</code><br/>
<code>#include &lt;nibo/delay.h&gt;</code><br/>
<code>#include &quot;gfxOutput.h&quot;</code><br/>
<code>#include &lt;nibo/floor.h&gt;</code><br/>
<code>#include &quot;protocols.h&quot;</code><br/>
<code>#include &quot;uart0.h&quot;</code><br/>
<code>#include &quot;n2switchS3.h&quot;</code><br/>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7d910bf412f8030adc33bf8f321d6b09"></a><!-- doxytag: member="protocols.c::SIDE_OUTSIDE_TURN_THRESHOLD" ref="a7d910bf412f8030adc33bf8f321d6b09" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>SIDE_OUTSIDE_TURN_THRESHOLD</b>&nbsp;&nbsp;&nbsp;20</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a786c92eea31c7ac7115553311627a8ed"></a><!-- doxytag: member="protocols.c::BLACK_UNDERGROUND" ref="a786c92eea31c7ac7115553311627a8ed" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>BLACK_UNDERGROUND</b>&nbsp;&nbsp;&nbsp;40</td></tr>
<tr><td colspan="2"><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><b>correctState</b> { <b>OUTSIDE</b> =  0, 
<b>INSIDE</b> =  1, 
<b>NON</b>
 }</td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="protocols_8c.html#a4175564c84c9ea1734d05487d0381613">setRecognizedBlackLine</a> (int reconized)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="protocols_8c.html#a97196c99591828a104db76de0ee8ae9d">getRecognizedBlackLine</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="protocols_8c.html#a713d22aabd221391555452ddadffcff3">getTurnDirection</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="protocols_8c.html#a4b9b85b5822852a8455aafc461ef292b">setStartValues</a> (int columns, int rows, int coordx, int coordy)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="protocols_8c.html#a20bbd4d45e3f01305dd709f5a9cc9952">clearBuffer</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="protocols_8c.html#abdf039faa32a14aa1e0ebafcee313cd8">receiveStartValues</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="protocols_8c.html#a977b75c49692727b1200866e31e9ee7f">receiveOutline</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="protocols_8c.html#a8715e716ca5d518249252beebe148ad3">sendMessageToNibo</a> (int signal)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="protocols_8c.html#a408dfd2160eda9b686b16ef90dfc3804">init_protocol</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="protocols_8c.html#aaad0b5a8e220ce74c3ff3f7e0c44587f">correctTrackToLeft</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="protocols_8c.html#a697fe3648aeeba978b2e3c764aa60f92">correctTrackToRight</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="protocols_8c.html#aa9e2a4000d223b74832f78c46e283f2e">correctTrackToInside</a> (int direction)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="protocols_8c.html#a8e220b4163ffdfb9707cabf54235074b">correctTrackToOutside</a> (int direction)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="protocols_8c.html#a81f400f7f87267ae36ec10b3d247be7d">leftTurnFree</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="protocols_8c.html#ab96274591cdfe803f0265f3f499e065c">leftTurnForced</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="protocols_8c.html#afd7447d92674d3fc31ca3504f68711f1">rightTurnFree</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="protocols_8c.html#a8330c85d05aa4f7874cb1215ecfa9a35">rightTurnForced</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="protocols_8c.html#a82d4a1788371d449da2e9d4dd1943fff">turnInside_protocol</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="protocols_8c.html#ae0a881d9136224b4b578acf4e3559b60">turnOutside_protocol</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="protocols_8c.html#abbdb87576aaa2b9c04f1055e8d6f0014">trackCorrection_protocol</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="protocols_8c.html#a555804c85be562414226956e84a9ad3b">floorCheck</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="protocols_8c.html#a35faab9f116bb90700579f5e4ca0d5bb">showOutline_protocol</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="protocols_8c.html#ac9b02ada097c5ea9e8616f2b58fb758c">finishRun_protocol</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="protocols_8c.html#a2920b5310183ca29a7cb727b7ab4b08f">runForward_protocol</a> ()</td></tr>
<tr><td colspan="2"><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a91354eaa902c9433b00aa6bf99350c8a"></a><!-- doxytag: member="protocols.c::correctState" ref="a91354eaa902c9433b00aa6bf99350c8a" args="" -->
enum correctState&nbsp;</td><td class="memItemRight" valign="bottom"><b>correctState</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="add228139a35e64fc6d3dcc704c5052de"></a><!-- doxytag: member="protocols.c::FRONT_THRESHOLD" ref="add228139a35e64fc6d3dcc704c5052de" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>FRONT_THRESHOLD</b> = 0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a076598671e03b4861c66be14baa886d1"></a><!-- doxytag: member="protocols.c::SIDE_THRESHOLD_OUTSIDE_MAX" ref="a076598671e03b4861c66be14baa886d1" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>SIDE_THRESHOLD_OUTSIDE_MAX</b> = 0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1d0654795ed27ed7128c6bfe0e44074d"></a><!-- doxytag: member="protocols.c::SIDE_THRESHOLD_OUTSIDE_MIN" ref="a1d0654795ed27ed7128c6bfe0e44074d" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>SIDE_THRESHOLD_OUTSIDE_MIN</b> = 0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad0c72c0e95d0269807a7643779134a32"></a><!-- doxytag: member="protocols.c::BLADE_THRESHOLD_OUTSIDE_MAX" ref="ad0c72c0e95d0269807a7643779134a32" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>BLADE_THRESHOLD_OUTSIDE_MAX</b> = 0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2fb9844afce115130ed387e73a97d25f"></a><!-- doxytag: member="protocols.c::BLADE_THRESHOLD_OUTSIDE_MIN" ref="a2fb9844afce115130ed387e73a97d25f" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>BLADE_THRESHOLD_OUTSIDE_MIN</b> = 0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab7bb4361de70e9b453f44afe0a09343d"></a><!-- doxytag: member="protocols.c::lastCorrectState" ref="ab7bb4361de70e9b453f44afe0a09343d" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>lastCorrectState</b> = -1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="affe361d868849f281d984db67a12a4fb"></a><!-- doxytag: member="protocols.c::reconizedBlackLine_send" ref="affe361d868849f281d984db67a12a4fb" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>reconizedBlackLine_send</b> = 0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afc8508c71ec826ae3db7b64995d992df"></a><!-- doxytag: member="protocols.c::turnDirection_send" ref="afc8508c71ec826ae3db7b64995d992df" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>turnDirection_send</b> = 0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acfbdbea68efe16581a6f8aea957590a3"></a><!-- doxytag: member="protocols.c::sensorIDSide" ref="acfbdbea68efe16581a6f8aea957590a3" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>sensorIDSide</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0c76778b8cf19c5ce31c34a14a943350"></a><!-- doxytag: member="protocols.c::sensorIDBlade" ref="a0c76778b8cf19c5ce31c34a14a943350" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>sensorIDBlade</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6d75769571f2b2a119984ffcbc5fbc34"></a><!-- doxytag: member="protocols.c::segmentWidth" ref="a6d75769571f2b2a119984ffcbc5fbc34" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>segmentWidth</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4a5cdf5e00705853ccee8f54ad2635f1"></a><!-- doxytag: member="protocols.c::segmentHeight" ref="a4a5cdf5e00705853ccee8f54ad2635f1" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>segmentHeight</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a617a47c70795bcff659815ad0efd2266"></a><!-- doxytag: member="protocols.c::counter" ref="a617a47c70795bcff659815ad0efd2266" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>counter</b> = 0</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Holds different protocols and util-methods for controlling nibo. </p>
<dl class="author"><dt><b>Author:</b></dt><dd>H.Tanke </dd></dl>
<dl class="version"><dt><b>Version:</b></dt><dd>1.0 </dd></dl>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a20bbd4d45e3f01305dd709f5a9cc9952"></a><!-- doxytag: member="protocols.c::clearBuffer" ref="a20bbd4d45e3f01305dd709f5a9cc9952" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clearBuffer </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sometimes the buffer of XBee communication will be filled randomly. This will be wiped to provide a better receiving from NIBOBrody. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00096"></a>00096                   {
<a name="l00097"></a>00097         <span class="keywordflow">while</span>(!uart0_rxempty()){
<a name="l00098"></a>00098                 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> received = uart0_getchar();
<a name="l00099"></a>00099         }
<a name="l00100"></a>00100 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="aa9e2a4000d223b74832f78c46e283f2e"></a><!-- doxytag: member="protocols.c::correctTrackToInside" ref="aa9e2a4000d223b74832f78c46e283f2e" args="(int direction)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void correctTrackToInside </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>direction</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Because there are 2 ways to move around the structure this method decides in which way the track will be corrected. To inside means to the center of structure. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>direction</em>&nbsp;</td><td>run direction in which the NIBO moves around structure </td></tr>
  </table>
  </dd>
</dl>

<p><div class="fragment"><pre class="fragment"><a name="l00279"></a>00279                                          {
<a name="l00280"></a>00280         <span class="keywordflow">if</span> (direction == LEFT_RUN) {
<a name="l00281"></a>00281                 <a class="code" href="protocols_8c.html#aaad0b5a8e220ce74c3ff3f7e0c44587f">correctTrackToLeft</a>();
<a name="l00282"></a>00282         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (direction == RIGHT_RUN) {
<a name="l00283"></a>00283                 <a class="code" href="protocols_8c.html#a697fe3648aeeba978b2e3c764aa60f92">correctTrackToRight</a>();
<a name="l00284"></a>00284         }
<a name="l00285"></a>00285 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="aaad0b5a8e220ce74c3ff3f7e0c44587f"></a><!-- doxytag: member="protocols.c::correctTrackToLeft" ref="aaad0b5a8e220ce74c3ff3f7e0c44587f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void correctTrackToLeft </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Instructs the nibo to correct its track to left. This helps nibo to follow the wall. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00259"></a>00259                           {
<a name="l00260"></a>00260         leds_set_status(LEDS_ORANGE, 4);
<a name="l00261"></a>00261         leds_set_status(LEDS_OFF, 5);
<a name="l00262"></a>00262         copro_setSpeed(10, 12);
<a name="l00263"></a>00263 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a8e220b4163ffdfb9707cabf54235074b"></a><!-- doxytag: member="protocols.c::correctTrackToOutside" ref="a8e220b4163ffdfb9707cabf54235074b" args="(int direction)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void correctTrackToOutside </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>direction</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Because there are 2 ways to move around the structure this method decides in which way the track will be corrected. To outside means away from center of structure. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>direction</em>&nbsp;</td><td>run direction in which the NIBO moves around structure </td></tr>
  </table>
  </dd>
</dl>

<p><div class="fragment"><pre class="fragment"><a name="l00292"></a>00292                                           {
<a name="l00293"></a>00293         <span class="keywordflow">if</span> (direction == LEFT_RUN) {
<a name="l00294"></a>00294                 <a class="code" href="protocols_8c.html#a697fe3648aeeba978b2e3c764aa60f92">correctTrackToRight</a>();
<a name="l00295"></a>00295         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (direction == RIGHT_RUN) {
<a name="l00296"></a>00296                 <a class="code" href="protocols_8c.html#aaad0b5a8e220ce74c3ff3f7e0c44587f">correctTrackToLeft</a>();
<a name="l00297"></a>00297         }
<a name="l00298"></a>00298 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a697fe3648aeeba978b2e3c764aa60f92"></a><!-- doxytag: member="protocols.c::correctTrackToRight" ref="a697fe3648aeeba978b2e3c764aa60f92" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void correctTrackToRight </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Instructs the nibo to correct its track to right. This helps NIBO to follow the wall. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00268"></a>00268                            {
<a name="l00269"></a>00269         leds_set_status(LEDS_ORANGE, 5);
<a name="l00270"></a>00270         leds_set_status(LEDS_OFF, 4);
<a name="l00271"></a>00271         copro_setSpeed(12, 10);
<a name="l00272"></a>00272 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ac9b02ada097c5ea9e8616f2b58fb758c"></a><!-- doxytag: member="protocols.c::finishRun_protocol" ref="ac9b02ada097c5ea9e8616f2b58fb758c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void finishRun_protocol </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This protocol will be started at the end of the measuring run around the structure. Its starting outline painting protocol. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00513"></a>00513                           {
<a name="l00514"></a>00514         <span class="comment">//sometimes buffer is filled before received any message from NIBOBrody. This could cause problems.</span>
<a name="l00515"></a>00515         <a class="code" href="protocols_8c.html#a20bbd4d45e3f01305dd709f5a9cc9952">clearBuffer</a>();
<a name="l00516"></a>00516         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 5; i++) {
<a name="l00517"></a>00517                 <span class="comment">//if showOutline protocol will fail it will be repeated several times.</span>
<a name="l00518"></a>00518                 <span class="keywordflow">if</span> (<a class="code" href="protocols_8c.html#a35faab9f116bb90700579f5e4ca0d5bb">showOutline_protocol</a>() == 1) {
<a name="l00519"></a>00519                         <span class="keywordflow">break</span>;
<a name="l00520"></a>00520                 }
<a name="l00521"></a>00521                 delay(500);
<a name="l00522"></a>00522         }
<a name="l00523"></a>00523         <a class="code" href="gfxOutput_8c.html#a493c2c13cad1ac88c3768c774ba62926">cleanDebug</a>(16);
<a name="l00524"></a>00524         <a class="code" href="gfxOutput_8c.html#a41f584b4caa5d0be2982dce84cb93642">printDebug</a>(<span class="stringliteral">&quot;End of communication!&quot;</span>);
<a name="l00525"></a>00525 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a555804c85be562414226956e84a9ad3b"></a><!-- doxytag: member="protocols.c::floorCheck" ref="a555804c85be562414226956e84a9ad3b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int floorCheck </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If the NIBO crosses a black line by moving around the structure with this method it will be noticed. After recognition this method will change the machine state to next state. It will start or stop the measuring process too. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>returns whether the floor sensors noticed a black line. </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00425"></a>00425                  {
<a name="l00426"></a>00426         floor_update();
<a name="l00427"></a>00427 
<a name="l00428"></a>00428         <span class="keywordflow">if</span> (reconizedBlackLine_send == 0
<a name="l00429"></a>00429                         &amp;&amp; (floor_relative[FLOOR_LEFT] &lt;= BLACK_UNDERGROUND
<a name="l00430"></a>00430                                         || floor_relative[FLOOR_RIGHT] &lt;= BLACK_UNDERGROUND)) {
<a name="l00431"></a>00431                 <span class="keywordflow">switch</span> (measure_State) {
<a name="l00432"></a>00432                 <span class="keywordflow">case</span> FINISHED:
<a name="l00433"></a>00433                         <a class="code" href="gfxOutput_8c.html#a493c2c13cad1ac88c3768c774ba62926">cleanDebug</a>(<span class="stringliteral">&quot;        &quot;</span>);
<a name="l00434"></a>00434                         <a class="code" href="gfxOutput_8c.html#a41f584b4caa5d0be2982dce84cb93642">printDebug</a>(<span class="stringliteral">&quot;Started!&quot;</span>);
<a name="l00435"></a>00435                         copro_resetOdometry(0, 0);
<a name="l00436"></a>00436                         measure_State = STARTED;
<a name="l00437"></a>00437                         copro_stop();
<a name="l00438"></a>00438                         <a class="code" href="protocols_8c.html#a8715e716ca5d518249252beebe148ad3">sendMessageToNibo</a>(1);
<a name="l00439"></a>00439                         <span class="keywordflow">break</span>;
<a name="l00440"></a>00440                 <span class="keywordflow">case</span> STARTED:
<a name="l00441"></a>00441                         <a class="code" href="gfxOutput_8c.html#a493c2c13cad1ac88c3768c774ba62926">cleanDebug</a>(<span class="stringliteral">&quot;         &quot;</span>);
<a name="l00442"></a>00442                         <a class="code" href="gfxOutput_8c.html#a41f584b4caa5d0be2982dce84cb93642">printDebug</a>(<span class="stringliteral">&quot;Finished!&quot;</span>);
<a name="l00443"></a>00443                         measure_State = FINISHED;
<a name="l00444"></a>00444                         machine_State = SENDING_DATA;
<a name="l00445"></a>00445                         copro_stop();
<a name="l00446"></a>00446                         <a class="code" href="protocols_8c.html#a8715e716ca5d518249252beebe148ad3">sendMessageToNibo</a>(0);
<a name="l00447"></a>00447                         <span class="keywordflow">break</span>;
<a name="l00448"></a>00448                 }
<a name="l00449"></a>00449                 reconizedBlackLine_send = 1;
<a name="l00450"></a>00450                 <span class="keywordflow">return</span> 1;
<a name="l00451"></a>00451         }
<a name="l00452"></a>00452         <span class="keywordflow">return</span> 0;
<a name="l00453"></a>00453 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a97196c99591828a104db76de0ee8ae9d"></a><!-- doxytag: member="protocols.c::getRecognizedBlackLine" ref="a97196c99591828a104db76de0ee8ae9d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getRecognizedBlackLine </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Getter for access from main file. Returns whether a black line on the floor was recognized. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>value whether a black line was recognized </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00062"></a>00062                              {
<a name="l00063"></a>00063         <span class="keywordflow">return</span> reconizedBlackLine_send;
<a name="l00064"></a>00064 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a713d22aabd221391555452ddadffcff3"></a><!-- doxytag: member="protocols.c::getTurnDirection" ref="a713d22aabd221391555452ddadffcff3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getTurnDirection </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Getter for access from main file. Returns the last turn direction. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>last turn direction (0 = left, 1 = right) </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00070"></a>00070                        {
<a name="l00071"></a>00071         <span class="keywordflow">return</span> turnDirection_send;
<a name="l00072"></a>00072 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a408dfd2160eda9b686b16ef90dfc3804"></a><!-- doxytag: member="protocols.c::init_protocol" ref="a408dfd2160eda9b686b16ef90dfc3804" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void init_protocol </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This protocol initializes NIBOJones. Its measuring distance to wall next to the nibo to set distance which shall be hold to the wall by moving around. Recognizing the movement direction part of this protocol too. There are two ways of moving direction, left and right run. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00196"></a>00196                      {
<a name="l00197"></a>00197         floor_init();
<a name="l00198"></a>00198         copro_update();
<a name="l00199"></a>00199         <a class="code" href="gfxOutput_8c.html#a41f584b4caa5d0be2982dce84cb93642">printDebug</a>(<span class="stringliteral">&quot;Initialization...&quot;</span>);
<a name="l00200"></a>00200         <a class="code" href="gfxOutput_8c.html#a9d6e5be17fcfe1285ad348f9d9ab5583">printMovingDirection</a>(run_direction);
<a name="l00201"></a>00201         <span class="keywordtype">int</span> averageDistance_SideLeft = 0;
<a name="l00202"></a>00202         <span class="keywordtype">int</span> averageDistance_SideRight = 0;
<a name="l00203"></a>00203         <span class="keywordtype">int</span> averageDistance_BladeLeft = 0;
<a name="l00204"></a>00204         <span class="keywordtype">int</span> averageDistance_BladeRight = 0;
<a name="l00205"></a>00205 
<a name="l00206"></a>00206         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 5; i++) {
<a name="l00207"></a>00207                 copro_update();
<a name="l00208"></a>00208                 averageDistance_SideLeft += copro_distance[4] / 256;
<a name="l00209"></a>00209                 averageDistance_SideRight += copro_distance[0] / 256;
<a name="l00210"></a>00210                 averageDistance_BladeLeft += copro_distance[3] / 256;
<a name="l00211"></a>00211                 averageDistance_BladeRight += copro_distance[1] / 256;
<a name="l00212"></a>00212                 delay(200);
<a name="l00213"></a>00213         }
<a name="l00214"></a>00214 
<a name="l00215"></a>00215         averageDistance_SideLeft = averageDistance_SideLeft / 5;
<a name="l00216"></a>00216         averageDistance_SideRight = averageDistance_SideRight / 5;
<a name="l00217"></a>00217         averageDistance_BladeLeft = averageDistance_BladeLeft / 5;
<a name="l00218"></a>00218         averageDistance_BladeRight = averageDistance_BladeRight / 5;
<a name="l00219"></a>00219 
<a name="l00220"></a>00220         <span class="keywordflow">if</span> (averageDistance_SideLeft &gt; averageDistance_SideRight) {
<a name="l00221"></a>00221                 run_direction = RIGHT_RUN;
<a name="l00222"></a>00222                 SIDE_THRESHOLD_OUTSIDE_MAX = averageDistance_SideLeft;
<a name="l00223"></a>00223                 SIDE_THRESHOLD_OUTSIDE_MIN = averageDistance_SideLeft - 20;
<a name="l00224"></a>00224                 BLADE_THRESHOLD_OUTSIDE_MAX = averageDistance_BladeLeft;
<a name="l00225"></a>00225                 BLADE_THRESHOLD_OUTSIDE_MIN = averageDistance_BladeLeft - 20;
<a name="l00226"></a>00226         } <span class="keywordflow">else</span> {
<a name="l00227"></a>00227                 run_direction = LEFT_RUN;
<a name="l00228"></a>00228                 SIDE_THRESHOLD_OUTSIDE_MAX = averageDistance_SideRight + 10;
<a name="l00229"></a>00229                 SIDE_THRESHOLD_OUTSIDE_MIN = averageDistance_SideRight - 10;
<a name="l00230"></a>00230                 BLADE_THRESHOLD_OUTSIDE_MAX = averageDistance_BladeRight + 10;
<a name="l00231"></a>00231                 BLADE_THRESHOLD_OUTSIDE_MIN = averageDistance_BladeRight - 10;
<a name="l00232"></a>00232         }
<a name="l00233"></a>00233 
<a name="l00234"></a>00234         FRONT_THRESHOLD = SIDE_THRESHOLD_OUTSIDE_MAX;
<a name="l00235"></a>00235 
<a name="l00236"></a>00236         <span class="keywordflow">if</span> (SIDE_THRESHOLD_OUTSIDE_MAX &gt; 250) {
<a name="l00237"></a>00237                 FRONT_THRESHOLD = FRONT_THRESHOLD - 30;
<a name="l00238"></a>00238         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (SIDE_THRESHOLD_OUTSIDE_MAX &gt; 230) {
<a name="l00239"></a>00239                 FRONT_THRESHOLD = FRONT_THRESHOLD - 10;
<a name="l00240"></a>00240         }
<a name="l00241"></a>00241 
<a name="l00242"></a>00242         <span class="keywordflow">if</span> (run_direction == LEFT_RUN) {
<a name="l00243"></a>00243                 sensorIDSide = 0;
<a name="l00244"></a>00244                 sensorIDBlade = 1;
<a name="l00245"></a>00245                 turnDirection_send = 0;
<a name="l00246"></a>00246         } <span class="keywordflow">else</span> {
<a name="l00247"></a>00247                 sensorIDSide = 4;
<a name="l00248"></a>00248                 sensorIDBlade = 3;
<a name="l00249"></a>00249                 turnDirection_send = 1;
<a name="l00250"></a>00250         }
<a name="l00251"></a>00251 
<a name="l00252"></a>00252         <a class="code" href="gfxOutput_8c.html#a493c2c13cad1ac88c3768c774ba62926">cleanDebug</a>(17);
<a name="l00253"></a>00253         <a class="code" href="gfxOutput_8c.html#a9d6e5be17fcfe1285ad348f9d9ab5583">printMovingDirection</a>(run_direction);
<a name="l00254"></a>00254 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ab96274591cdfe803f0265f3f499e065c"></a><!-- doxytag: member="protocols.c::leftTurnForced" ref="ab96274591cdfe803f0265f3f499e065c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void leftTurnForced </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>For outside turns the NIBOs looses contact to walls and is free in field. In this situation the nibo has to perform a 90° turn of its own. Use this method to perform a right turn. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00324"></a>00324                       {
<a name="l00325"></a>00325         turnDirection_send = 0;
<a name="l00326"></a>00326         leds_set_status(LEDS_ORANGE, 3);
<a name="l00327"></a>00327         copro_setTargetRel(-27, 27, 10);
<a name="l00328"></a>00328         delay(2000);
<a name="l00329"></a>00329         leds_set_status(LEDS_OFF, 3);
<a name="l00330"></a>00330 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a81f400f7f87267ae36ec10b3d247be7d"></a><!-- doxytag: member="protocols.c::leftTurnFree" ref="a81f400f7f87267ae36ec10b3d247be7d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void leftTurnFree </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>With this method the NIBO is able to turn left at a corner as inside turn. Because the NIBO is not able to perform perfect 90° turns its orientating on the corner and its wall to perform its turn. Those wall and corner have to be positioned as 90° corner! </p>

<p><div class="fragment"><pre class="fragment"><a name="l00305"></a>00305                     {
<a name="l00306"></a>00306         turnDirection_send = 0;
<a name="l00307"></a>00307         leds_set_status(LEDS_ORANGE, 3);
<a name="l00308"></a>00308         <span class="keywordflow">while</span> (1 == 1) {
<a name="l00309"></a>00309                 copro_update();
<a name="l00310"></a>00310                 copro_setSpeed(-10, 15);
<a name="l00311"></a>00311                 <span class="keywordflow">if</span> (copro_distance[2] / 256 &lt; 100 &amp;&amp; copro_distance[1] / 256 &lt; 50) {
<a name="l00312"></a>00312                         copro_stop();
<a name="l00313"></a>00313                         leds_set_status(LEDS_OFF, 3);
<a name="l00314"></a>00314                         <span class="keywordflow">return</span>;
<a name="l00315"></a>00315                 }
<a name="l00316"></a>00316         }
<a name="l00317"></a>00317 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a977b75c49692727b1200866e31e9ee7f"></a><!-- doxytag: member="protocols.c::receiveOutline" ref="a977b75c49692727b1200866e31e9ee7f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int receiveOutline </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The message which contains parts of the outline figur are slightly different and need a own function. Because sometimes xbee messages are failing, this function listens for several seconds until closing. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>returns whether there was received a message in time. </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00137"></a>00137                      {
<a name="l00138"></a>00138         <span class="keywordtype">int</span> byte;
<a name="l00139"></a>00139 
<a name="l00140"></a>00140         <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> received;
<a name="l00141"></a>00141         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 10; i++) {
<a name="l00142"></a>00142                 <span class="keywordflow">if</span> (!uart0_rxempty()) {
<a name="l00143"></a>00143                         received = uart0_getchar();
<a name="l00144"></a>00144                         byte = received;
<a name="l00145"></a>00145                         <span class="keywordflow">if</span> ((byte &amp; 128) == 128) {
<a name="l00146"></a>00146                                 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> answer = byte &amp; 255;
<a name="l00147"></a>00147                                 <span class="keywordflow">if</span> (!uart0_txfull()) {
<a name="l00148"></a>00148                                         uart0_putchar(answer);
<a name="l00149"></a>00149                                         delay(200);
<a name="l00150"></a>00150                                 }
<a name="l00151"></a>00151                                 <span class="keywordflow">return</span> byte;
<a name="l00152"></a>00152                         }
<a name="l00153"></a>00153                 }
<a name="l00154"></a>00154                 delay(400);
<a name="l00155"></a>00155         }
<a name="l00156"></a>00156         <span class="keywordflow">return</span> -1;
<a name="l00157"></a>00157 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="abdf039faa32a14aa1e0ebafcee313cd8"></a><!-- doxytag: member="protocols.c::receiveStartValues" ref="abdf039faa32a14aa1e0ebafcee313cd8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int receiveStartValues </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The message which contains parts of the start values are slightly different and need a own function. Because sometimes xbee messages are failing, this function listens for several seconds. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>returns whether there was received a message in time. </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00108"></a>00108                          {
<a name="l00109"></a>00109         <span class="keywordtype">int</span> byte;
<a name="l00110"></a>00110         <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> received;
<a name="l00111"></a>00111         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 20; i++) {
<a name="l00112"></a>00112                 <span class="keywordflow">if</span> (!uart0_rxempty()) {
<a name="l00113"></a>00113                         received = uart0_getchar();
<a name="l00114"></a>00114                         byte = received;
<a name="l00115"></a>00115                         <span class="keywordflow">if</span> ((byte &amp; 128) == 128) {
<a name="l00116"></a>00116                                 <span class="comment">//sending acknowledgment</span>
<a name="l00117"></a>00117                                 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> answer = byte &amp; 255;
<a name="l00118"></a>00118                                 <span class="keywordflow">if</span> (!uart0_txfull()) {
<a name="l00119"></a>00119                                         uart0_putchar(answer);
<a name="l00120"></a>00120                                         delay(200);
<a name="l00121"></a>00121                                 }
<a name="l00122"></a>00122                                 <span class="keywordflow">return</span> byte &amp; 127;
<a name="l00123"></a>00123                         }
<a name="l00124"></a>00124                 }
<a name="l00125"></a>00125                 delay(200);
<a name="l00126"></a>00126         }
<a name="l00127"></a>00127 
<a name="l00128"></a>00128         <span class="keywordflow">return</span> -1;
<a name="l00129"></a>00129 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a8330c85d05aa4f7874cb1215ecfa9a35"></a><!-- doxytag: member="protocols.c::rightTurnForced" ref="a8330c85d05aa4f7874cb1215ecfa9a35" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rightTurnForced </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>For outside turns the NIBOs looses contact to walls and is free in field. In this situation the nibo has to perform a 90° turn of its own. Use this method to perform a left turn. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00356"></a>00356                        {
<a name="l00357"></a>00357         turnDirection_send = 1;
<a name="l00358"></a>00358         leds_set_status(LEDS_ORANGE, 6);
<a name="l00359"></a>00359         copro_setTargetRel(27, -27, 10);
<a name="l00360"></a>00360         delay(2000);
<a name="l00361"></a>00361         leds_set_status(LEDS_OFF, 6);
<a name="l00362"></a>00362 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="afd7447d92674d3fc31ca3504f68711f1"></a><!-- doxytag: member="protocols.c::rightTurnFree" ref="afd7447d92674d3fc31ca3504f68711f1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rightTurnFree </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>With this method the NIBO is able to turn right at a corner as inside turn. Because the NIBO is not able to perform perfect 90° turns its orientating on the corner and its wall to perform its turn. Those wall and corner have to be positioned as 90° corner! </p>

<p><div class="fragment"><pre class="fragment"><a name="l00337"></a>00337                      {
<a name="l00338"></a>00338         turnDirection_send = 1;
<a name="l00339"></a>00339         leds_set_status(LEDS_ORANGE, 6);
<a name="l00340"></a>00340         <span class="keywordflow">while</span> (1 == 1) {
<a name="l00341"></a>00341                 copro_update();
<a name="l00342"></a>00342                 copro_setSpeed(15, -10);
<a name="l00343"></a>00343                 <span class="keywordflow">if</span> (copro_distance[2] / 256 &lt; 100 &amp;&amp; copro_distance[3] / 256 &lt; 50) {
<a name="l00344"></a>00344                         copro_stop();
<a name="l00345"></a>00345                         leds_set_status(LEDS_OFF, 6);
<a name="l00346"></a>00346                         <span class="keywordflow">return</span>;
<a name="l00347"></a>00347                 }
<a name="l00348"></a>00348         }
<a name="l00349"></a>00349 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a2920b5310183ca29a7cb727b7ab4b08f"></a><!-- doxytag: member="protocols.c::runForward_protocol" ref="a2920b5310183ca29a7cb727b7ab4b08f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void runForward_protocol </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This protocol controls the NIBO by running forward. Its the main protocol too and starts all others protcolls by setting machine state. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00531"></a>00531                            {
<a name="l00532"></a>00532         copro_update();
<a name="l00533"></a>00533         <span class="keywordtype">int</span> front = copro_distance[2] / 256;
<a name="l00534"></a>00534         <span class="keywordtype">int</span> side_outside = copro_distance[run_direction] / 256;
<a name="l00535"></a>00535 
<a name="l00536"></a>00536         <span class="keywordflow">if</span> (s3_was_pressed()) {
<a name="l00537"></a>00537                 machine_State = WAITING;
<a name="l00538"></a>00538                 <span class="keywordflow">return</span>;
<a name="l00539"></a>00539         }
<a name="l00540"></a>00540 
<a name="l00541"></a>00541         <span class="comment">//if a black line was recognized this will perform a hard switch of machine state to improve reaction time.</span>
<a name="l00542"></a>00542         <span class="keywordflow">if</span> (<a class="code" href="protocols_8c.html#a555804c85be562414226956e84a9ad3b">floorCheck</a>() == 1) {
<a name="l00543"></a>00543                 <span class="keywordflow">return</span>;
<a name="l00544"></a>00544         }
<a name="l00545"></a>00545 
<a name="l00546"></a>00546         <span class="keywordflow">if</span> (front &gt;= FRONT_THRESHOLD) { <span class="comment">//wall on front</span>
<a name="l00547"></a>00547                 copro_stop();
<a name="l00548"></a>00548                 machine_State = TURNING_INSIDE;
<a name="l00549"></a>00549         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (run_direction
<a name="l00550"></a>00550                         != UNKNOWN&amp;&amp; side_outside &lt; SIDE_OUTSIDE_TURN_THRESHOLD) { <span class="comment">// loosed contact to wall on side</span>
<a name="l00551"></a>00551                 machine_State = TURNING_OUTSIDE;
<a name="l00552"></a>00552                 delay(1000);
<a name="l00553"></a>00553                 copro_stop();
<a name="l00554"></a>00554         } <span class="keywordflow">else</span> { <span class="comment">//no wall on front or loosed contact to wall on side</span>
<a name="l00555"></a>00555                 machine_State = TRACK_CORRECTION;
<a name="l00556"></a>00556         }
<a name="l00557"></a>00557 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a8715e716ca5d518249252beebe148ad3"></a><!-- doxytag: member="protocols.c::sendMessageToNibo" ref="a8715e716ca5d518249252beebe148ad3" args="(int signal)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sendMessageToNibo </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>signal</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This message sends a signal to NIBOShorty so it can start playing music and showing picture. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>signal</em>&nbsp;</td><td>sets start signal (1 = start, 0 = stop) </td></tr>
  </table>
  </dd>
</dl>

<p><div class="fragment"><pre class="fragment"><a name="l00163"></a>00163                                    {
<a name="l00164"></a>00164         <span class="comment">// signal indicates the start or end of the music</span>
<a name="l00165"></a>00165         <span class="comment">// this message addresses the NIBO, so the indication bit has to be 0</span>
<a name="l00166"></a>00166         <span class="keywordtype">int</span> byte = signal;
<a name="l00167"></a>00167         <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> message = byte &amp; 255;
<a name="l00168"></a>00168         <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> answer;
<a name="l00169"></a>00169         <span class="keywordtype">int</span> i = 0;
<a name="l00170"></a>00170         <span class="keywordflow">while</span> (1) {
<a name="l00171"></a>00171                 <span class="keywordflow">if</span> (!uart0_txfull()) {
<a name="l00172"></a>00172                         uart0_putchar(message);
<a name="l00173"></a>00173                 }
<a name="l00174"></a>00174                 delay(200);
<a name="l00175"></a>00175                 <span class="keywordflow">if</span> (!uart0_rxempty()) {
<a name="l00176"></a>00176                         <span class="comment">// wait for answer</span>
<a name="l00177"></a>00177                         answer = uart0_getchar();
<a name="l00178"></a>00178                         byte = answer;
<a name="l00179"></a>00179                         <span class="keywordflow">if</span> ((byte &amp; 128) != 0) {
<a name="l00180"></a>00180                                 <span class="comment">// wrong indicator</span>
<a name="l00181"></a>00181                                 <span class="keywordflow">continue</span>;
<a name="l00182"></a>00182                         }
<a name="l00183"></a>00183                         <span class="keywordflow">break</span>;
<a name="l00184"></a>00184                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (i == 5) {
<a name="l00185"></a>00185                         <span class="keywordflow">break</span>;
<a name="l00186"></a>00186                 }
<a name="l00187"></a>00187                 i++;
<a name="l00188"></a>00188         }
<a name="l00189"></a>00189 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a4175564c84c9ea1734d05487d0381613"></a><!-- doxytag: member="protocols.c::setRecognizedBlackLine" ref="a4175564c84c9ea1734d05487d0381613" args="(int reconized)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setRecognizedBlackLine </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>reconized</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Setter for acccess from main file. Sets whether a black line on the ground was recognized. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>reconized</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

<p><div class="fragment"><pre class="fragment"><a name="l00054"></a>00054                                            {
<a name="l00055"></a>00055         reconizedBlackLine_send = reconized;
<a name="l00056"></a>00056 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a4b9b85b5822852a8455aafc461ef292b"></a><!-- doxytag: member="protocols.c::setStartValues" ref="a4b9b85b5822852a8455aafc461ef292b" args="(int columns, int rows, int coordx, int coordy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setStartValues </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>columns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>coordx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>coordy</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets and calculates start values for right positioning of outline on display. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>columns</em>&nbsp;</td><td>numbers columns the outline pictures has (width) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rows</em>&nbsp;</td><td>numbers columns the outline pictures has (height) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>coordx</em>&nbsp;</td><td>x coordinate of the start point for painting </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>coordy</em>&nbsp;</td><td>y coordinate of the start point for painting </td></tr>
  </table>
  </dd>
</dl>

<p><div class="fragment"><pre class="fragment"><a name="l00081"></a>00081                                                                    {
<a name="l00082"></a>00082         <span class="comment">//by using 50 the outline will be placed more on the upper boarder of display.</span>
<a name="l00083"></a>00083         <span class="comment">//In this way, below the outline is place for a debug outprint with further informations</span>
<a name="l00084"></a>00084         segmentWidth = 50 / columns;
<a name="l00085"></a>00085         segmentHeight = 50 / rows;
<a name="l00086"></a>00086         <span class="comment">//startx coordinate will be manipulated so the whole outline is placed in the middle of the display.</span>
<a name="l00087"></a>00087         <span class="keywordtype">int</span> startx = (segmentWidth * coordx) + ((128 - segmentWidth * columns) / 2);
<a name="l00088"></a>00088         <span class="keywordtype">int</span> starty = (segmentHeight * coordy) + 5;
<a name="l00089"></a>00089         <a class="code" href="gfxOutput_8c.html#a062dfb790cc03254d7b2db6541fc139c">setStartPointForOutline</a>(startx, starty);
<a name="l00090"></a>00090 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a35faab9f116bb90700579f5e4ca0d5bb"></a><!-- doxytag: member="protocols.c::showOutline_protocol" ref="a35faab9f116bb90700579f5e4ca0d5bb" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int showOutline_protocol </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This protocol will paint the outline of moved around and measured structure on NIBOs display. Receiving data from NIBOBrody for painting is also part of this protocol. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>returns whether all data for paining was received successfully. </dd></dl>

<p><div class="fragment"><pre class="fragment"><a name="l00460"></a>00460                            {
<a name="l00461"></a>00461         <a class="code" href="gfxOutput_8c.html#a41f584b4caa5d0be2982dce84cb93642">printDebug</a>(<span class="stringliteral">&quot;Start receiving&quot;</span>);
<a name="l00462"></a>00462         <span class="keywordtype">int</span> columns = <a class="code" href="protocols_8c.html#abdf039faa32a14aa1e0ebafcee313cd8">receiveStartValues</a>();
<a name="l00463"></a>00463         <span class="keywordflow">if</span> (columns == -1) {
<a name="l00464"></a>00464                 <a class="code" href="gfxOutput_8c.html#a493c2c13cad1ac88c3768c774ba62926">cleanDebug</a>(20);
<a name="l00465"></a>00465                 <a class="code" href="gfxOutput_8c.html#a41f584b4caa5d0be2982dce84cb93642">printDebug</a>(<span class="stringliteral">&quot;ERROR: columns&quot;</span>);
<a name="l00466"></a>00466                 <span class="keywordflow">return</span> -1;
<a name="l00467"></a>00467         }
<a name="l00468"></a>00468         <span class="keywordtype">int</span> rows = <a class="code" href="protocols_8c.html#abdf039faa32a14aa1e0ebafcee313cd8">receiveStartValues</a>();
<a name="l00469"></a>00469         <span class="keywordflow">if</span> (columns == -1) {
<a name="l00470"></a>00470                 <a class="code" href="gfxOutput_8c.html#a493c2c13cad1ac88c3768c774ba62926">cleanDebug</a>(20);
<a name="l00471"></a>00471                 <a class="code" href="gfxOutput_8c.html#a41f584b4caa5d0be2982dce84cb93642">printDebug</a>(<span class="stringliteral">&quot;ERROR: rows&quot;</span>);
<a name="l00472"></a>00472                 <span class="keywordflow">return</span> -1;
<a name="l00473"></a>00473         }
<a name="l00474"></a>00474         <span class="keywordtype">int</span> startX = <a class="code" href="protocols_8c.html#abdf039faa32a14aa1e0ebafcee313cd8">receiveStartValues</a>();
<a name="l00475"></a>00475         <span class="keywordflow">if</span> (columns == -1) {
<a name="l00476"></a>00476                 <a class="code" href="gfxOutput_8c.html#a493c2c13cad1ac88c3768c774ba62926">cleanDebug</a>(20);
<a name="l00477"></a>00477                 <a class="code" href="gfxOutput_8c.html#a41f584b4caa5d0be2982dce84cb93642">printDebug</a>(<span class="stringliteral">&quot;ERROR: startx&quot;</span>);
<a name="l00478"></a>00478                 <span class="keywordflow">return</span> -1;
<a name="l00479"></a>00479         }
<a name="l00480"></a>00480         <span class="keywordtype">int</span> startY = <a class="code" href="protocols_8c.html#abdf039faa32a14aa1e0ebafcee313cd8">receiveStartValues</a>();
<a name="l00481"></a>00481         <span class="keywordflow">if</span> (columns == -1) {
<a name="l00482"></a>00482                 <a class="code" href="gfxOutput_8c.html#a493c2c13cad1ac88c3768c774ba62926">cleanDebug</a>(20);
<a name="l00483"></a>00483                 <a class="code" href="gfxOutput_8c.html#a41f584b4caa5d0be2982dce84cb93642">printDebug</a>(<span class="stringliteral">&quot;ERROR: starty&quot;</span>);
<a name="l00484"></a>00484                 <span class="keywordflow">return</span> -1;
<a name="l00485"></a>00485         }
<a name="l00486"></a>00486         <a class="code" href="gfxOutput_8c.html#a493c2c13cad1ac88c3768c774ba62926">cleanDebug</a>(20);
<a name="l00487"></a>00487         <a class="code" href="gfxOutput_8c.html#a41f584b4caa5d0be2982dce84cb93642">printDebug</a>(<span class="stringliteral">&quot;connect successful&quot;</span>);
<a name="l00488"></a>00488         <a class="code" href="protocols_8c.html#a4b9b85b5822852a8455aafc461ef292b">setStartValues</a>(columns, rows, startX, startY);
<a name="l00489"></a>00489 
<a name="l00490"></a>00490         <span class="keywordtype">int</span> isFinished = 0;
<a name="l00491"></a>00491         <span class="keywordtype">int</span> byte = -1;
<a name="l00492"></a>00492 
<a name="l00493"></a>00493         <span class="keywordflow">while</span> (!isFinished) {
<a name="l00494"></a>00494                 isFinished = 1;
<a name="l00495"></a>00495                 byte = <a class="code" href="protocols_8c.html#a977b75c49692727b1200866e31e9ee7f">receiveOutline</a>();
<a name="l00496"></a>00496                 <span class="keywordflow">if</span> (byte != -1) {
<a name="l00497"></a>00497                         <a class="code" href="gfxOutput_8c.html#a9b87978627d97af1119a304c290d750c">showOutline</a>(byte, segmentHeight, segmentWidth);
<a name="l00498"></a>00498                         isFinished = 0;
<a name="l00499"></a>00499                         <span class="keywordflow">break</span>;
<a name="l00500"></a>00500                 } <span class="keywordflow">else</span> {
<a name="l00501"></a>00501                         delay(200);
<a name="l00502"></a>00502                 }
<a name="l00503"></a>00503                 byte = -1;
<a name="l00504"></a>00504         }
<a name="l00505"></a>00505 
<a name="l00506"></a>00506         <span class="keywordflow">return</span> 1;
<a name="l00507"></a>00507 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="abbdb87576aaa2b9c04f1055e8d6f0014"></a><!-- doxytag: member="protocols.c::trackCorrection_protocol" ref="abbdb87576aaa2b9c04f1055e8d6f0014" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void trackCorrection_protocol </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This protocol corrects the track of NIBO running forward to prevent collision with wall on the sides. Its correcting to inside or outside. In case of specific run direction it a correction to left or right </p>

<p><div class="fragment"><pre class="fragment"><a name="l00394"></a>00394                                 {
<a name="l00395"></a>00395         copro_update();
<a name="l00396"></a>00396         <span class="comment">//if side sensors value hits threshold of nearest distance to wall.</span>
<a name="l00397"></a>00397         <span class="keywordflow">if</span> (copro_distance[sensorIDSide] / 256 &gt; SIDE_THRESHOLD_OUTSIDE_MAX
<a name="l00398"></a>00398                         || copro_distance[sensorIDBlade] / 256
<a name="l00399"></a>00399                                         &gt; BLADE_THRESHOLD_OUTSIDE_MAX) {
<a name="l00400"></a>00400                 correctState = INSIDE;
<a name="l00401"></a>00401                 <a class="code" href="protocols_8c.html#aa9e2a4000d223b74832f78c46e283f2e">correctTrackToInside</a>(run_direction);
<a name="l00402"></a>00402         <span class="comment">//if side sensor value hits threshold of most far distance to wall.</span>
<a name="l00403"></a>00403         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (copro_distance[sensorIDSide] / 256 &lt; SIDE_THRESHOLD_OUTSIDE_MIN
<a name="l00404"></a>00404                         || copro_distance[sensorIDBlade] / 256
<a name="l00405"></a>00405                                         &lt; BLADE_THRESHOLD_OUTSIDE_MIN) {
<a name="l00406"></a>00406                 correctState = OUTSIDE;
<a name="l00407"></a>00407                 <a class="code" href="protocols_8c.html#a8e220b4163ffdfb9707cabf54235074b">correctTrackToOutside</a>(run_direction);
<a name="l00408"></a>00408         } <span class="keywordflow">else</span> {
<a name="l00409"></a>00409                 correctState = NON;
<a name="l00410"></a>00410                 leds_set_status(LEDS_OFF, 4);
<a name="l00411"></a>00411                 leds_set_status(LEDS_OFF, 5);
<a name="l00412"></a>00412                 copro_setSpeed(10, 10);
<a name="l00413"></a>00413         }
<a name="l00414"></a>00414 
<a name="l00415"></a>00415         lastCorrectState = correctState;
<a name="l00416"></a>00416         machine_State = RUNNING_FORWARD;
<a name="l00417"></a>00417 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a82d4a1788371d449da2e9d4dd1943fff"></a><!-- doxytag: member="protocols.c::turnInside_protocol" ref="a82d4a1788371d449da2e9d4dd1943fff" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turnInside_protocol </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>There are different ways for NIBOJones to run around the structure. This method decides whether left or right shall be choosen to turn to inside of structure. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00368"></a>00368                            {
<a name="l00369"></a>00369         <span class="keywordflow">if</span> (run_direction == LEFT_RUN) {
<a name="l00370"></a>00370                 <a class="code" href="protocols_8c.html#a81f400f7f87267ae36ec10b3d247be7d">leftTurnFree</a>();
<a name="l00371"></a>00371         } <span class="keywordflow">else</span> {
<a name="l00372"></a>00372                 <a class="code" href="protocols_8c.html#afd7447d92674d3fc31ca3504f68711f1">rightTurnFree</a>();
<a name="l00373"></a>00373         }
<a name="l00374"></a>00374 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ae0a881d9136224b4b578acf4e3559b60"></a><!-- doxytag: member="protocols.c::turnOutside_protocol" ref="ae0a881d9136224b4b578acf4e3559b60" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turnOutside_protocol </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>There are different ways for NIBOJones to run around the structure. This method decides whether left or right shall be choosen to turn to outside of structure. </p>

<p><div class="fragment"><pre class="fragment"><a name="l00380"></a>00380                             {
<a name="l00381"></a>00381         <span class="keywordflow">if</span> (run_direction == LEFT_RUN) {
<a name="l00382"></a>00382                 <a class="code" href="protocols_8c.html#a8330c85d05aa4f7874cb1215ecfa9a35">rightTurnForced</a>();
<a name="l00383"></a>00383         } <span class="keywordflow">else</span> {
<a name="l00384"></a>00384                 <a class="code" href="protocols_8c.html#ab96274591cdfe803f0265f3f499e065c">leftTurnForced</a>();
<a name="l00385"></a>00385         }
<a name="l00386"></a>00386         delay(1000);
<a name="l00387"></a>00387 }
</pre></div></p>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Functions</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address style="text-align: right;"><small>Generated on Fri Dec 14 14:29:20 2018 for NIBOJones by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
